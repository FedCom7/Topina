/**
 * TOPINA LEAGUE - Fantasy NFL Stats
 * Dynamic Home based on NFL Season Period
 */


document.addEventListener('DOMContentLoaded', () => {

    // Initialize all modules
    initNavbar();
    initScrollAnimations();
    initCounterAnimations();
    initTableAnimations();
    initRoundSelector();
    initParallax();

    // Home page specific
    if (document.getElementById('home')) {
        initSeasonPeriod();
        updateStadiumBackground();
        initDebugSelector();
        // Initialize NFL Phase Indicator from calendar API
        initNFLPhaseIndicator();
    }
});



/**
 * NFL Calendar API Configuration
 */
const NFL_CALENDAR_URL = 'https://app.stanzacal.com/api/calendar/webcal/nfl-allgames/61661215437db10008aae4b3/66e197347c4d9fb301eaa25b.ics';

/**
 * Initialize NFL Phase Indicator from calendar API
 */
async function initNFLPhaseIndicator() {
    const indicator = document.getElementById('nfl-phase-indicator');
    const labelElement = document.getElementById('phase-label');
    const emojiElement = indicator?.querySelector('.phase-emoji');

    if (!indicator || !labelElement) return;

    try {
        const phase = await getNFLPhaseFromCalendar();

        // Update label and emoji
        labelElement.textContent = phase.label;
        if (emojiElement) emojiElement.textContent = phase.emoji;

        // Add phase-specific class for styling
        indicator.classList.remove('preseason', 'regular-season', 'playoffs', 'super-bowl', 'offseason', 'draft');
        indicator.classList.add(phase.cssClass);

    } catch (error) {
        console.warn('Could not fetch NFL calendar, using fallback:', error);
        // Fallback to local season detection
        const fallbackPhase = getFallbackNFLPhase();
        labelElement.textContent = fallbackPhase.label;
        if (emojiElement) emojiElement.textContent = fallbackPhase.emoji;
        indicator.classList.add(fallbackPhase.cssClass);
    }
}

/**
 * Fetch and parse the NFL calendar to determine current phase
 */
async function getNFLPhaseFromCalendar() {
    // Use a CORS proxy since the API might block direct browser requests
    // Try direct first, then fall back to proxy
    let icsData;

    try {
        // Try direct fetch first
        const response = await fetch(NFL_CALENDAR_URL);
        if (!response.ok) throw new Error('Direct fetch failed');
        icsData = await response.text();
    } catch (directError) {
        // Try with CORS proxy
        try {
            const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(NFL_CALENDAR_URL)}`;
            const proxyResponse = await fetch(proxyUrl);
            if (!proxyResponse.ok) throw new Error('Proxy fetch failed');
            icsData = await proxyResponse.text();
        } catch (proxyError) {
            throw new Error('Both direct and proxy fetch failed');
        }
    }

    // Parse the ICS data
    const events = parseICSCalendar(icsData);

    // Determine current phase from events
    return determineNFLPhase(events);
}

/**
 * Parse ICS calendar data into event objects
 */
function parseICSCalendar(icsData) {
    const events = [];
    const eventBlocks = icsData.split('BEGIN:VEVENT');

    for (let i = 1; i < eventBlocks.length; i++) {
        const block = eventBlocks[i];
        const endIndex = block.indexOf('END:VEVENT');
        const eventData = block.substring(0, endIndex);

        // Extract date
        const dtStartMatch = eventData.match(/DTSTART:(\d{8}T\d{6}Z?)/);
        const summaryMatch = eventData.match(/SUMMARY:(.+)/);

        if (dtStartMatch && summaryMatch) {
            const dateStr = dtStartMatch[1];
            const year = parseInt(dateStr.substring(0, 4));
            const month = parseInt(dateStr.substring(4, 6)) - 1;
            const day = parseInt(dateStr.substring(6, 8));
            const hour = parseInt(dateStr.substring(9, 11));
            const minute = parseInt(dateStr.substring(11, 13));

            events.push({
                date: new Date(Date.UTC(year, month, day, hour, minute)),
                summary: summaryMatch[1].trim()
            });
        }
    }

    // Sort by date
    events.sort((a, b) => a.date - b.date);

    return events;
}

/**
 * Determine NFL phase based on parsed events and current date
 */
function determineNFLPhase(events) {
    const now = new Date();

    // Filter out past events and get future events
    const futureEvents = events.filter(e => e.date > now);
    const pastEvents = events.filter(e => e.date <= now);

    // Find the current season (based on most recent/upcoming games)
    // NFL season typically runs September to February

    // Check for Super Bowl (usually the last game around early February)
    const superBowlEvent = events.find(e =>
        e.summary.toLowerCase().includes('super bowl') ||
        (e.date.getMonth() === 1 && events.indexOf(e) === events.length - 1)
    );

    // Check if we're near Super Bowl
    if (superBowlEvent) {
        const msUntilSB = superBowlEvent.date - now;
        const daysUntilSB = msUntilSB / (1000 * 60 * 60 * 24);

        if (daysUntilSB >= 0 && daysUntilSB <= 7) {
            return { label: 'Super Bowl Week', emoji: 'üèÜ', cssClass: 'super-bowl' };
        }
        if (daysUntilSB < 0 && daysUntilSB >= -14) {
            return { label: 'Super Bowl Complete', emoji: 'üèÜ', cssClass: 'super-bowl' };
        }
    }

    // Group events by week
    const regularSeasonEvents = events.filter(e => {
        // Regular season: September through early January
        const month = e.date.getMonth();
        return (month >= 8 || month === 0); // Sept (8) through Jan (0)
    });

    if (regularSeasonEvents.length > 0) {
        // Find regular season start/end
        const seasonStart = regularSeasonEvents[0].date;
        const seasonEnd = regularSeasonEvents[regularSeasonEvents.length - 1].date;

        // Check if we're in regular season
        if (now >= seasonStart && now <= seasonEnd) {
            // Calculate current week
            const weekNumber = calculateNFLWeek(now, regularSeasonEvents);

            // Check if playoffs (after week 18, usually)
            if (weekNumber > 18) {
                return { label: 'Playoffs', emoji: 'üî•', cssClass: 'playoffs' };
            }

            return { label: `Week ${weekNumber}`, emoji: 'üèà', cssClass: 'regular-season' };
        }

        // Before season starts
        if (now < seasonStart) {
            // Check if it's preseason (August)
            if (now.getMonth() === 7) {
                return { label: 'Preseason', emoji: 'üí™', cssClass: 'preseason' };
            }

            // Check draft period (late April)
            if (now.getMonth() === 3 && now.getDate() >= 20) {
                return { label: 'Draft', emoji: 'üìã', cssClass: 'draft' };
            }

            return { label: 'Offseason', emoji: '‚è≥', cssClass: 'offseason' };
        }

        // After regular season
        if (now > seasonEnd) {
            // Check playoffs (January)
            if (now.getMonth() === 0) {
                // Wild Card, Divisional, Conference Championship
                const dayOfMonth = now.getDate();
                if (dayOfMonth <= 7) {
                    return { label: 'Wild Card', emoji: 'üî•', cssClass: 'playoffs' };
                } else if (dayOfMonth <= 14) {
                    return { label: 'Divisional Round', emoji: 'üî•', cssClass: 'playoffs' };
                } else if (dayOfMonth <= 21) {
                    return { label: 'Conference Championship', emoji: 'üî•', cssClass: 'playoffs' };
                } else {
                    return { label: 'Super Bowl Week', emoji: 'üèÜ', cssClass: 'super-bowl' };
                }
            }

            // February (Super Bowl / Post Season)
            if (now.getMonth() === 1) {
                if (now.getDate() <= 15) {
                    return { label: 'Super Bowl Week', emoji: 'üèÜ', cssClass: 'super-bowl' };
                }
                return { label: 'Offseason', emoji: '‚è≥', cssClass: 'offseason' };
            }
        }
    }

    // Fallback
    return getFallbackNFLPhase();
}

/**
 * Calculate the current NFL week based on events
 */
function calculateNFLWeek(currentDate, events) {
    // NFL weeks are Thursday to Wednesday
    // Find which "batch" of games we're in

    // Group events by week (games within 7 days of each other are same week)
    const weeks = [];
    let currentWeekEvents = [];
    let lastEventDate = null;

    for (const event of events) {
        if (lastEventDate) {
            const daysDiff = (event.date - lastEventDate) / (1000 * 60 * 60 * 24);

            // If more than 4 days since last event, it's a new week
            if (daysDiff > 4) {
                if (currentWeekEvents.length > 0) {
                    weeks.push(currentWeekEvents);
                }
                currentWeekEvents = [];
            }
        }

        currentWeekEvents.push(event);
        lastEventDate = event.date;
    }

    // Don't forget the last week
    if (currentWeekEvents.length > 0) {
        weeks.push(currentWeekEvents);
    }

    // Find which week we're in
    for (let i = 0; i < weeks.length; i++) {
        const weekEvents = weeks[i];
        const weekStart = new Date(weekEvents[0].date);
        weekStart.setDate(weekStart.getDate() - 3); // Start 3 days before first game

        const weekEnd = new Date(weekEvents[weekEvents.length - 1].date);
        weekEnd.setDate(weekEnd.getDate() + 3); // End 3 days after last game

        if (currentDate >= weekStart && currentDate <= weekEnd) {
            return i + 1;
        }
    }

    // If between weeks, return next upcoming week
    for (let i = 0; i < weeks.length; i++) {
        if (weeks[i][0].date > currentDate) {
            return i + 1;
        }
    }

    return weeks.length;
}

/**
 * Fallback phase detection using fixed dates
 */
function getFallbackNFLPhase() {
    const now = new Date();
    const month = now.getMonth();
    const day = now.getDate();

    // February: Super Bowl period or post-Super Bowl
    if (month === 1) {
        if (day <= 15) {
            return { label: 'Super Bowl', emoji: 'üèÜ', cssClass: 'super-bowl' };
        }
        return { label: 'Offseason', emoji: '‚è≥', cssClass: 'offseason' };
    }

    // March - April: Offseason / Draft
    if (month === 2) {
        return { label: 'Offseason', emoji: '‚è≥', cssClass: 'offseason' };
    }

    if (month === 3) {
        if (day >= 24 && day <= 27) {
            return { label: 'Draft', emoji: 'üìã', cssClass: 'draft' };
        }
        return { label: 'Offseason', emoji: '‚è≥', cssClass: 'offseason' };
    }

    // May - July: Offseason
    if (month >= 4 && month <= 6) {
        return { label: 'Offseason', emoji: '‚è≥', cssClass: 'offseason' };
    }

    // August: Preseason
    if (month === 7) {
        return { label: 'Preseason', emoji: 'üí™', cssClass: 'preseason' };
    }

    // September - December: Regular Season
    if (month >= 8 && month <= 11) {
        // Rough week calculation
        const seasonStart = new Date(now.getFullYear(), 8, 5); // Sept 5
        const weeksSinceStart = Math.floor((now - seasonStart) / (7 * 24 * 60 * 60 * 1000));
        const week = Math.min(Math.max(weeksSinceStart + 1, 1), 18);
        return { label: `Week ${week}`, emoji: 'üèà', cssClass: 'regular-season' };
    }

    // January: Playoffs
    if (month === 0) {
        if (day <= 7) {
            return { label: 'Wild Card', emoji: 'üî•', cssClass: 'playoffs' };
        } else if (day <= 14) {
            return { label: 'Divisional', emoji: 'üî•', cssClass: 'playoffs' };
        } else if (day <= 21) {
            return { label: 'Championship', emoji: 'üî•', cssClass: 'playoffs' };
        } else {
            return { label: 'Super Bowl Week', emoji: 'üèÜ', cssClass: 'super-bowl' };
        }
    }

    return { label: 'NFL', emoji: 'üèà', cssClass: 'regular-season' };
}

/**
 * Parallax scroll effect
 */
function initParallax() {
    const layers = document.querySelectorAll('.parallax .layer');
    if (layers.length === 0) return;

    function parallax() {
        const y = window.scrollY;
        for (let i = 1; i < layers.length; i++) {
            layers[layers.length - i].style.transform = `translateY(${(i * 0.1) * y}px)`;
        }
    }

    window.addEventListener('scroll', parallax, false);
}

/**
 * NFL Season Periods Configuration
 * Adjust dates according to the actual NFL calendar
 */
const NFL_DATES = {
    // 2024-2025 Season (example dates - adjust as needed)
    draftStart: new Date('2025-04-24'),
    draftEnd: new Date('2025-04-26'),
    seasonStart: new Date('2024-09-05'),
    seasonEnd: new Date('2025-01-05'),
    playoffsStart: new Date('2025-01-11'),
    superBowl: new Date('2025-02-09'),
    // Post Super Bowl celebration period (2 weeks)
    celebrationEnd: new Date('2025-02-23'),
};

// Current champion data (update after each season)
// Current champion data (update after each season)
const CURRENT_CHAMPION = {
    name: 'Loading...',
    logo: 'üèÜ',
    record: '-',
    year: '-'
};

// Fantasy Super Bowl Finalists - NOW DYNAMIC
// Will be populated by fetchSuperBowlMatchup
let SUPER_BOWL_FINALISTS = {
    teamTop: 'TBD',
    teamBottom: 'TBD',
    isActive: false,
    matchup: null // Will store full matchup details
};

// Stadium background images for each matchup
const STADIUM_IMAGES = {
    'capi_lasers': 'images/sb_capi_lasers.png',
    'capi_oscurus': 'images/sb_capi_oscurus.png',
    'capi_sommo': 'images/sb_capi_sommo.png',
    'lasers_oscurus': 'images/sb_lasers_oscurus.png',
    'lasers_sommo': 'images/sb_lasers_sommo.png',
    'oscurus_sommo': 'images/sb_oscurus_sommo.png',
    'default': 'images/stadium_bg.png'
};

// Team name to key mapping
// Team name to key mapping - keeping for stadium background logic
const TEAM_KEYS = {
    'Capi dei Pianeti': 'capi',
    'Lasers': 'lasers',
    'Oscurus': 'oscurus',
    'Sommo': 'sommo',
    'Thunder Hawks': 'thunder', // Added for 2024 Finalist
    'Riccardo97': 'riccardo'    // Added just in case
};

// Team logo paths
// Team logo paths - Update with generic fallback or ensure all teams have logos
// In a real app, these would come from the DB too
const TEAM_LOGOS = {
    'Capi dei Pianeti': 'Team Logo/IMG_1065.JPG',
    'Lasers': 'Team Logo/IMG_4979.JPG',
    'Oscurus': 'Team Logo/IMG_8063.JPG',
    'Sommo': 'Team Logo/IMG_8064.JPG'
};

/**
 * Get stadium image for a matchup
 */
function getStadiumImage(team1, team2) {
    const key1 = TEAM_KEYS[team1];
    const key2 = TEAM_KEYS[team2];

    if (!key1 || !key2) return STADIUM_IMAGES.default;

    // Sort keys alphabetically to match image naming
    const sortedKeys = [key1, key2].sort();
    const matchupKey = sortedKeys.join('_');

    return STADIUM_IMAGES[matchupKey] || STADIUM_IMAGES.default;
}

/**
 * Update stadium background based on finalists
 */
function updateStadiumBackground() {
    const homeSection = document.querySelector('.home-section');
    if (!homeSection) return;

    const period = getSeasonPeriod();

    // Show finalists during playoffs and Super Bowl periods
    if ((period === 'PLAYOFFS' || period === 'POST_SUPER_BOWL') || SUPER_BOWL_FINALISTS.isActive) {
        // Update stadium background to show correct matchup
        // const stadiumImage = getStadiumImage(
        //     SUPER_BOWL_FINALISTS.teamTop,
        //     SUPER_BOWL_FINALISTS.teamBottom
        // );
        // homeSection.style.backgroundImage = `url('${stadiumImage}')`;
        // Use gradient instead to remove "Topina Obscurus League" text
        homeSection.style.backgroundImage = 'none';
        homeSection.style.background = 'radial-gradient(circle at center, #1a1a2e 0%, #0a0a0f 100%)';
    } else {
        // Off-season: show default stadium
        // homeSection.style.backgroundImage = `url('${STADIUM_IMAGES.default}')`;
        homeSection.style.backgroundImage = 'none';
        homeSection.style.background = 'radial-gradient(circle at center, #1a1a2e 0%, #0a0a0f 100%)';
    }
}

/**
 * Initialize debug matchup selector
 */
function initDebugSelector() {
    // Handle period selector
    const periodSelect = document.getElementById('period-select');
    if (periodSelect) {
        periodSelect.addEventListener('change', (e) => {
            const selectedPeriod = e.target.value;
            if (selectedPeriod === 'auto') {
                // Use actual period
                initSeasonPeriod();
            } else {
                // Override with selected period
                initSeasonPeriodWithOverride(selectedPeriod);
            }
        });

        // Initialize with selected value (defaults to Super Bowl Week)
        const initialPeriod = periodSelect.value;
        if (initialPeriod !== 'auto') {
            initSeasonPeriodWithOverride(initialPeriod);
        }
    }

    // Handle matchup photo selector (only active in Super Bowl section)
    const matchupSelect = document.getElementById('matchup-select');
    if (matchupSelect) {
        matchupSelect.addEventListener('change', (e) => {
            const homeSection = document.querySelector('.home-section');
            if (!homeSection) return;

            const matchup = e.target.value;
            if (matchup === 'default') {
                homeSection.style.backgroundImage = `url('${STADIUM_IMAGES.default}')`;
            } else {
                homeSection.style.backgroundImage = `url('${STADIUM_IMAGES[matchup]}')`;
            }
        });
    }
}

/**
 * Initialize season period with override (for debug)
 */
async function initSeasonPeriodWithOverride(period) {
    console.log('initSeasonPeriodWithOverride called with:', period);

    const periodConfig = {
        POST_SUPER_BOWL: {
            icon: 'üèÜ',
            text: 'Championship Celebration',
            message: 'Congratulations to our Champion!',
            section: 'postseason-section',
            showPhotoSelector: false,
            showHomeSection: false  // Hide stadium for Post-Season
        },
        PLAYOFFS: {
            icon: 'üî•',
            text: 'Super Bowl Week',
            message: 'The championship game is here!',
            section: 'superbowl-section',
            showPhotoSelector: true,
            showHomeSection: true  // Show stadium for Super Bowl Week
        },
        REGULAR_SEASON: {
            icon: 'üèà',
            text: 'Regular Season',
            message: 'Every game counts. Build your legacy.',
            section: 'gameweek-section',
            showPhotoSelector: false,
            showHomeSection: false  // Hide stadium for Game Week
        },
        PRE_DRAFT: {
            icon: '‚è≥',
            text: 'Pre-Draft',
            message: 'Prepare your strategy. The draft is coming.',
            section: 'predraft-section',
            showPhotoSelector: false,
            showHomeSection: false  // Hide stadium for Pre-Draft
        }
    };

    const config = periodConfig[period];
    if (!config) {
        console.log('No config found for period:', period);
        return;
    }

    console.log('Using config:', config);

    // Show/hide the home section (stadium) based on period
    const homeSection = document.getElementById('home');
    const homeContentSection = document.querySelector('.home-content-section');

    if (homeSection) {
        if (config.showHomeSection) {
            homeSection.classList.remove('hidden');
        } else {
            homeSection.classList.add('hidden');
        }
    }

    if (homeContentSection) {
        if (config.showHomeSection) {
            homeContentSection.classList.remove('hidden');
        } else {
            homeContentSection.classList.add('hidden');
        }
    }

    // Use PeriodManager for layout changes FIRST
    // This must happen before showing sections so PeriodManager can control visibility
    if (window.PeriodManager) {
        // If it's Super Bowl Week or Playoffs, fetch real data
        if (period === 'PLAYOFFS' || period === 'POST_SUPER_BOWL') {
            console.log('[initSeasonPeriodWithOverride] Fetching Super Bowl data...');
            // Fetch Week 17 (Championship) data if not already loaded or if we want to refresh
            const matchup = await fetchSuperBowlMatchup(CURRENT_SEASON);
            console.log('[initSeasonPeriodWithOverride] Matchup data received:', matchup);

            if (matchup) {
                SUPER_BOWL_FINALISTS = {
                    teamTop: matchup.team1.name,
                    teamBottom: matchup.team2.name,
                    isActive: true,
                    matchup: matchup
                };
            }
        }

        console.log('[initSeasonPeriodWithOverride] Calling PeriodManager.apply for:', period);
        window.PeriodManager.apply(period, {
            finalists: SUPER_BOWL_FINALISTS
        });
    } else {
        console.error('[togglePeriodVisibility] PeriodManager not loaded!');
    }

    // For PLAYOFFS period, PeriodManager handles everything - skip standard logic
    if (period === 'PLAYOFFS') {
        console.log('[togglePeriodVisibility] Super Bowl Week - PeriodManager handles layout');
        return; // Exit early, PeriodManager has full control
    }

    // Update period badge (only for non-Super Bowl periods)
    const badge = document.getElementById('period-badge');
    if (badge) {
        badge.querySelector('.period-icon').textContent = config.icon;
        badge.querySelector('.period-text').textContent = config.text;
    }

    // Update message (only for non-Super Bowl periods)
    const message = document.getElementById('period-message');
    if (message) {
        message.textContent = config.message;
    }

    // Hide all period sections first
    document.querySelectorAll('.period-section').forEach(section => {
        section.classList.add('hidden');
    });

    // Show the appropriate section (only for non-Super Bowl periods)
    const targetSection = document.getElementById(config.section);
    console.log('Target section:', config.section, 'Element:', targetSection);

    if (targetSection) {
        targetSection.classList.remove('hidden');
        console.log('Section shown, classList:', targetSection.classList);

        // Initialize section-specific content
        initSectionContent(period, config.section);
    }

    // Show/hide photo selector based on period
    const photoSelector = document.getElementById('debug-photo-selector');
    if (photoSelector) {
        if (config.showPhotoSelector) {
            photoSelector.style.display = 'flex';
        } else {
            photoSelector.style.display = 'none';
        }
    }
}

/**
 * Initialize Super Bowl Countdown Timer
 * Counts down to NFL Week 17 start (Fantasy Super Bowl)
 */
function initSuperBowlCountdown() {
    // NFL Week 17 2024-2025 season typically starts around late December
    // Adjust this date based on actual NFL schedule
    const week17Start = new Date('2024-12-28T13:00:00');

    function updateCountdown() {
        const now = new Date();
        const diff = week17Start - now;

        if (diff <= 0) {
            // Super Bowl is happening!
            document.getElementById('countdown-days').textContent = '00';
            document.getElementById('countdown-hours').textContent = '00';
            document.getElementById('countdown-minutes').textContent = '00';
            document.getElementById('countdown-seconds').textContent = '00';
            document.querySelector('.countdown-title').textContent = 'üèÜ SUPER BOWL TIME! üèÜ';
            return;
        }

        const days = Math.floor(diff / (1000 * 60 * 60 * 24));
        const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
        const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((diff % (1000 * 60)) / 1000);

        document.getElementById('countdown-days').textContent = String(days).padStart(2, '0');
        document.getElementById('countdown-hours').textContent = String(hours).padStart(2, '0');
        document.getElementById('countdown-minutes').textContent = String(minutes).padStart(2, '0');
        document.getElementById('countdown-seconds').textContent = String(seconds).padStart(2, '0');
    }

    // Update immediately and then every second
    updateCountdown();
    setInterval(updateCountdown, 1000);
}

/**
 * Initialize Super Bowl Parallax Scroll Effect
 * Reveals trophy and team logos when scrolling down
 */
function initSuperBowlParallax() {
    const parallaxReveal = document.getElementById('superbowl-parallax-reveal');
    if (!parallaxReveal) return;

    const homeSection = document.getElementById('home');
    if (!homeSection) return;

    function handleScroll() {
        const scrollY = window.scrollY;
        const homeSectionHeight = homeSection.offsetHeight;

        // Start revealing when scrolled past 100px, fully visible at 300px
        const scrollThreshold = 100;
        const scrollMaxEffect = 300;

        if (scrollY > scrollThreshold) {
            // Calculate progress (0 to 1)
            const progress = Math.min((scrollY - scrollThreshold) / (scrollMaxEffect - scrollThreshold), 1);

            // Add visible class to trigger CSS transitions
            parallaxReveal.classList.add('visible');

            // Additional parallax effect on trophy (moves up as you scroll)
            const trophy = parallaxReveal.querySelector('.parallax-trophy');
            if (trophy) {
                trophy.style.transform = `scale(${0.5 + progress * 0.5}) translateY(${50 - progress * 50}px)`;
                trophy.style.opacity = progress;
            }
        } else {
            parallaxReveal.classList.remove('visible');
        }

        // Hide parallax when scrolled past home section
        if (scrollY > homeSectionHeight) {
            parallaxReveal.style.opacity = '0';
        } else {
            parallaxReveal.style.opacity = '';
        }
    }

    window.addEventListener('scroll', handleScroll);
    // Run once on init
    handleScroll();
}

/**
 * Route to appropriate section content initializer
 */
function initSectionContent(period, sectionId) {
    console.log('initSectionContent:', period, sectionId);
    switch (sectionId) {
        case 'superbowl-section':
            initSuperBowlSection();
            break;
        case 'postseason-section':
            initPostSeasonSection();
            break;
        case 'predraft-section':
            initPreDraftSection();
            break;
        case 'gameweek-section':
            initGameWeekSection(period);
            break;
    }
}

/**
 * Initialize Super Bowl section content
 */
function initSuperBowlSection() {
    // Placeholder data - will be replaced with real data from backend
    const team1 = { name: 'Capi dei Pianeti', logo: 'üü†', record: '10-4', pf: 1532, pa: 1298, streak: 'W4' };
    const team2 = { name: 'Lasers', logo: 'üü°', record: '11-3', pf: 1645, pa: 1310, streak: 'W6' };

    // Team 1
    document.getElementById('sb-team1-name').textContent = team1.name;
    document.getElementById('sb-team1-logo').textContent = team1.logo;
    document.getElementById('sb-team1-record').textContent = team1.record;

    // Team 2
    document.getElementById('sb-team2-name').textContent = team2.name;
    document.getElementById('sb-team2-logo').textContent = team2.logo;
    document.getElementById('sb-team2-record').textContent = team2.record;

    // Stats comparison
    document.getElementById('sb-stat1-pf').textContent = team1.pf;
    document.getElementById('sb-stat2-pf').textContent = team2.pf;
    document.getElementById('sb-stat1-pa').textContent = team1.pa;
    document.getElementById('sb-stat2-pa').textContent = team2.pa;
    document.getElementById('sb-stat1-streak').textContent = team1.streak;
    document.getElementById('sb-stat2-streak').textContent = team2.streak;
}

/**
 * Initialize Post-Season section content
 */
function initPostSeasonSection() {
    // Placeholder section - elements may not exist
    console.log('Post-Season section loaded (placeholder)');
}

/**
 * Initialize Pre-Draft section content
 */
function initPreDraftSection() {
    // Placeholder section - elements may not exist
    console.log('Pre-Draft section loaded (placeholder)');
}

/**
 * Initialize Game Week section content
 */
function initGameWeekSection(period) {
    // Placeholder section - elements may not exist
    console.log('Game Week section loaded (placeholder)');
}

/**
 * Determine current season period
 */
function getSeasonPeriod() {
    const now = new Date();

    // Check each period
    if (now >= NFL_DATES.superBowl && now <= NFL_DATES.celebrationEnd) {
        return 'POST_SUPER_BOWL';
    } else if (now >= NFL_DATES.playoffsStart && now < NFL_DATES.superBowl) {
        return 'PLAYOFFS';
    } else if (now >= NFL_DATES.seasonStart && now < NFL_DATES.playoffsStart) {
        return 'REGULAR_SEASON';
    } else if (now >= NFL_DATES.draftStart && now <= NFL_DATES.draftEnd) {
        return 'DRAFT_WEEKEND';
    } else if (now < NFL_DATES.draftStart) {
        return 'PRE_DRAFT';
    } else if (now > NFL_DATES.draftEnd && now < NFL_DATES.seasonStart) {
        return 'PRE_SEASON';
    } else {
        return 'OFF_SEASON';
    }
}

/**
 * Initialize season period display
 */
function initSeasonPeriod() {
    const period = getSeasonPeriod();

    const periodConfig = {
        POST_SUPER_BOWL: {
            icon: 'üèÜ',
            text: 'Championship Celebration',
            message: 'Congratulations to our Champion!',
            showChampion: true,
            showCountdown: false,
            confetti: true,
            showHomeSection: true
        },
        PLAYOFFS: {
            icon: 'üî•',
            text: 'Playoffs',
            message: 'The road to the championship is on!',
            showChampion: false,
            showCountdown: true,
            countdownTarget: NFL_DATES.superBowl,
            countdownTitle: 'Super Bowl Countdown',
            confetti: false,
            showHomeSection: true
        },
        REGULAR_SEASON: {
            icon: 'üèà',
            text: 'Regular Season',
            message: 'Every game counts. Build your legacy.',
            showChampion: false,
            showCountdown: false,
            confetti: false,
            showHomeSection: true
        },
        DRAFT_WEEKEND: {
            icon: 'üìã',
            text: 'Draft Weekend',
            message: 'The future is being written. Choose wisely.',
            showChampion: false,
            showCountdown: false,
            confetti: true,
            showHomeSection: true
        },
        PRE_DRAFT: {
            icon: '‚è≥',
            text: 'Pre-Draft',
            message: 'Prepare your strategy. The draft is coming.',
            showChampion: false,
            showCountdown: true,
            countdownTarget: NFL_DATES.draftStart,
            countdownTitle: 'Days Until Draft',
            confetti: false,
            showHomeSection: true
        },
        PRE_SEASON: {
            icon: 'üí™',
            text: 'Pre-Season',
            message: 'Training camp is here. Season starts soon.',
            showChampion: false,
            showCountdown: true,
            countdownTarget: NFL_DATES.seasonStart,
            countdownTitle: 'Season Kickoff',
            confetti: false,
            showHomeSection: true
        },
        OFF_SEASON: {
            icon: 'üò¥',
            text: 'Off-Season',
            message: 'Rest up. The grind returns soon.',
            showChampion: false,
            showCountdown: true,
            countdownTarget: NFL_DATES.draftStart,
            countdownTitle: 'Days Until Draft',
            confetti: false,
            showHomeSection: true
        }
    };

    const config = periodConfig[period];

    // Update period badge
    const badge = document.getElementById('period-badge');
    if (badge) {
        badge.querySelector('.period-icon').textContent = config.icon;
        badge.querySelector('.period-text').textContent = config.text;
    }

    // Update message
    const message = document.getElementById('period-message');
    if (message) {
        message.textContent = config.message;
    }

    // Show/hide champion section
    const championSection = document.getElementById('champion-section');
    if (championSection) {
        if (config.showChampion) {
            championSection.classList.remove('hidden');
            document.getElementById('champion-name').textContent = CURRENT_CHAMPION.name;
            document.getElementById('champion-logo').textContent = CURRENT_CHAMPION.logo;
        } else {
            championSection.classList.add('hidden');
        }
    }

    // Show/hide countdown section
    const countdownSection = document.getElementById('countdown-section');
    if (countdownSection) {
        if (config.showCountdown) {
            countdownSection.classList.remove('hidden');
            document.getElementById('countdown-title').textContent = config.countdownTitle;
            startCountdown(config.countdownTarget);
        } else {
            countdownSection.classList.add('hidden');
        }
    }

    // Start confetti if needed
    if (config.confetti) {
        setTimeout(() => {
            startConfetti();
        }, 1000);
    }
}

/**
 * Countdown timer
 */
function startCountdown(targetDate) {
    function updateCountdown() {
        const now = new Date();
        const diff = targetDate - now;

        if (diff <= 0) {
            document.getElementById('countdown-days').textContent = '00';
            document.getElementById('countdown-hours').textContent = '00';
            document.getElementById('countdown-minutes').textContent = '00';
            return;
        }

        const days = Math.floor(diff / (1000 * 60 * 60 * 24));
        const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
        const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));

        document.getElementById('countdown-days').textContent = String(days).padStart(2, '0');
        document.getElementById('countdown-hours').textContent = String(hours).padStart(2, '0');
        document.getElementById('countdown-minutes').textContent = String(minutes).padStart(2, '0');
    }

    updateCountdown();
    setInterval(updateCountdown, 60000); // Update every minute
}

/**
 * Confetti Effect
 */
function startConfetti() {
    const canvas = document.getElementById('confetti-canvas');
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const confettiColors = ['#ffffff', '#fbbf24', '#22c55e', '#3b82f6', '#ef4444', '#a855f7'];
    const confettiCount = 150;
    const confetti = [];

    // Create confetti particles
    for (let i = 0; i < confettiCount; i++) {
        confetti.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height - canvas.height,
            w: Math.random() * 10 + 5,
            h: Math.random() * 6 + 4,
            color: confettiColors[Math.floor(Math.random() * confettiColors.length)],
            speed: Math.random() * 3 + 2,
            angle: Math.random() * 360,
            spin: Math.random() * 10 - 5,
            opacity: Math.random() * 0.5 + 0.5
        });
    }

    let animationFrame;
    let startTime = Date.now();
    const duration = 8000; // 8 seconds

    function animate() {
        const elapsed = Date.now() - startTime;

        if (elapsed > duration) {
            // Fade out
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            cancelAnimationFrame(animationFrame);
            return;
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        confetti.forEach(c => {
            ctx.save();
            ctx.translate(c.x + c.w / 2, c.y + c.h / 2);
            ctx.rotate((c.angle * Math.PI) / 180);
            ctx.globalAlpha = c.opacity;
            ctx.fillStyle = c.color;
            ctx.fillRect(-c.w / 2, -c.h / 2, c.w, c.h);
            ctx.restore();

            // Update position
            c.y += c.speed;
            c.angle += c.spin;
            c.x += Math.sin(c.angle * 0.1) * 0.5;

            // Reset if off screen
            if (c.y > canvas.height) {
                c.y = -20;
                c.x = Math.random() * canvas.width;
            }
        });

        animationFrame = requestAnimationFrame(animate);
    }

    animate();

    // Handle resize
    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    });
}

/**
 * Navbar scroll effect
 */
function initNavbar() {
    const navbar = document.querySelector('.navbar');
    if (!navbar) return;

    window.addEventListener('scroll', () => {
        if (window.scrollY > 50) {
            navbar.classList.add('scrolled');
        } else {
            navbar.classList.remove('scrolled');
        }
    });
}

/**
 * Scroll-triggered animations using Intersection Observer
 */
function initScrollAnimations() {
    const animatedElements = document.querySelectorAll('.animate-on-scroll');

    const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                const delay = entry.target.dataset.delay || 0;
                setTimeout(() => {
                    entry.target.classList.add('visible');
                }, delay);
            }
        });
    }, {
        threshold: 0.1,
        rootMargin: '0px 0px -50px 0px'
    });

    animatedElements.forEach(el => observer.observe(el));
}

/**
 * Counter animation for statistics
 */
function initCounterAnimations() {
    const counters = document.querySelectorAll('[data-count]');

    const animateCounter = (counter) => {
        const target = parseInt(counter.dataset.count);
        const duration = 2000;
        const step = target / (duration / 16);
        let current = 0;

        const updateCounter = () => {
            current += step;
            if (current < target) {
                counter.textContent = formatNumber(Math.floor(current));
                requestAnimationFrame(updateCounter);
            } else {
                counter.textContent = formatNumber(target);
            }
        };

        updateCounter();
    };

    const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting && !entry.target.classList.contains('counted')) {
                entry.target.classList.add('counted');
                animateCounter(entry.target);
            }
        });
    }, {
        threshold: 0.5
    });

    counters.forEach(counter => observer.observe(counter));
}

/**
 * Format number with commas
 */
function formatNumber(num) {
    return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
}

/**
 * Staggered table row animations
 */
function initTableAnimations() {
    const tableRows = document.querySelectorAll('.table-row');

    const observer = new IntersectionObserver((entries) => {
        entries.forEach((entry, index) => {
            if (entry.isIntersecting) {
                const rank = entry.target.dataset.rank || index;
                setTimeout(() => {
                    entry.target.classList.add('visible');
                }, rank * 100);
            }
        });
    }, {
        threshold: 0.1
    });

    tableRows.forEach(row => observer.observe(row));
}

/**
 * Round selector for draft page
 */
function initRoundSelector() {
    const roundBtns = document.querySelectorAll('.round-btn');

    roundBtns.forEach(btn => {
        btn.addEventListener('click', () => {
            // Remove active from all
            roundBtns.forEach(b => b.classList.remove('active'));
            // Add active to clicked
            btn.classList.add('active');

            // Here you would filter the draft cards based on round
            const round = btn.dataset.round;
            console.log('Selected round:', round);
            // Implement filtering logic as needed
        });
    });
}

/**
 * Manual trigger for confetti (for testing)
 */
function triggerConfetti() {
    startConfetti();
}

// Expose to global for testing
window.triggerConfetti = triggerConfetti;

import { db } from './js/firebase-config.js';
import { ref, child, get } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-database.js";

/**
 * ========================================
 * NFL FANTASY DATA LOADING (FIREBASE RTDB)
 * ========================================
 */

// Current active season for the frontend
const CURRENT_SEASON = '2024';

/**
 * Fetch draft data from Firestore
 */
/**
 * Fetch draft data from Realtime Database
 */
async function fetchDraftData(season = CURRENT_SEASON) {
    try {
        const dbRef = ref(db);
        const snapshot = await get(child(dbRef, `draft/draft_data_${season}`));

        if (snapshot.exists()) {
            return snapshot.val();
        } else {
            console.log("No draft data found for season:", season);
            return null;
        }
    } catch (error) {
        console.error("Error getting draft data:", error);
        return null;
    }
}

/**
 * Fetch fantasy data from Realtime Database
 */
async function fetchFantasyData(season = CURRENT_SEASON) {
    const dbPath = `fantasy/fantasy_data_${season}`;
    console.log(`[fetchFantasyData] Attempting to fetch: ${dbPath}`);
    try {
        const dbRef = ref(db);
        const snapshot = await get(child(dbRef, dbPath));

        if (snapshot.exists()) {
            console.log(`[fetchFantasyData] Successfully fetched ${dbPath}`);
            return snapshot.val();
        } else {
            console.warn(`[fetchFantasyData] Data not available: ${dbPath}`);
            return null;
        }
    } catch (error) {
        console.error(`[fetchFantasyData] Error fetching ${dbPath}:`, error);
        return null;
    }
}

/**
 * Convert structured draft data (by team) into a flat array for the grid
 */
function flattenDraftData(draftData) {
    if (!draftData || !draftData.teams) return [];

    const flatPicks = [];

    // Iterate over each team
    Object.entries(draftData.teams).forEach(([fantasyTeam, picks]) => {
        picks.forEach(pick => {
            flatPicks.push({
                pick: pick.pick,
                round: Math.ceil(pick.pick / 4), // Assuming 4 teams? Need to check league size or calculate from pick
                playerName: pick.name,
                position: pick.position,
                nflTeam: pick.nfl_team,
                fantasyTeam: fantasyTeam
            });
        });
    });

    // Validating round calculation: using standard snake draft logic if needed, 
    // but the simple math above might be wrong if league size isn't 4.
    // Let's infer round from pick number if not present, or better yet, rely on the fact 
    // that we want to sort by pick number anyway.
    // *Correction*: The prompt's JSON had "pick": 1, 8, 9 for first team.
    // If it's a 4 team league:
    // R1: 1-4, R2: 5-8, R3: 9-12. 
    // Pick 8 is R2. Pick 9 is R3. 
    // Math.ceil(8/4) = 2. Math.ceil(9/4) = 3. 
    // Matches 4 teams logic. Topina seems to be 4 teams (Capi, Lasers, Oscurus, FedCom/Sommo?).
    // Let's determine league size dynamically or hardcode if known.
    // Based on `js/periods/superbowl-week.js` finalists, we saw 4 teams.
    const leagueSize = Object.keys(draftData.teams).length || 4;

    flatPicks.forEach(p => {
        p.round = Math.ceil(p.pick / leagueSize);
    });

    // Sort by pick number
    return flatPicks.sort((a, b) => a.pick - b.pick);
}

/**
 * Process fantasy data to calculate standings
 */
function processFantasyData(fantasyData) {
    if (!fantasyData || !fantasyData.weeks) return [];

    const teams = {};

    // Helper to init team stats
    const initTeam = (name) => {
        if (!teams[name]) {
            teams[name] = {
                teamName: name,
                wins: 0,
                losses: 0,
                ties: 0,
                pointsFor: 0,
                pointsAgainst: 0,
                streak: [] // Will store 'W', 'L', 'T' to calculate current streak
            };
        }
    };

    // Iterate through weeks
    Object.values(fantasyData.weeks).forEach(week => {
        if (!week.matchups) return;

        week.matchups.forEach(matchup => {
            // Check if matchup has team1 and team2 (sometimes bye weeks exist, but assuming full matchups)
            if (matchup.team1 && matchup.team2) {
                const t1 = matchup.team1;
                const t2 = matchup.team2;

                initTeam(t1.name);
                initTeam(t2.name);

                const s1 = parseFloat(t1.score);
                const s2 = parseFloat(t2.score);

                // Update points
                teams[t1.name].pointsFor += s1;
                teams[t1.name].pointsAgainst += s2;
                teams[t2.name].pointsFor += s2;
                teams[t2.name].pointsAgainst += s1;

                // Update records
                if (s1 > s2) {
                    teams[t1.name].wins++;
                    teams[t2.name].losses++;
                    teams[t1.name].streak.push('W');
                    teams[t2.name].streak.push('L');
                } else if (s2 > s1) {
                    teams[t2.name].wins++;
                    teams[t1.name].losses++;
                    teams[t2.name].streak.push('W');
                    teams[t1.name].streak.push('L');
                } else {
                    teams[t1.name].ties++;
                    teams[t2.name].ties++;
                    teams[t1.name].streak.push('T');
                    teams[t2.name].streak.push('T');
                }
            }
        });
    });

    // Format standings array
    const standings = Object.values(teams).map(team => {
        // Calculate current streak string (e.g., "W3", "L1")
        let currentStreak = '';
        if (team.streak.length > 0) {
            let count = 0;
            const type = team.streak[team.streak.length - 1];
            for (let i = team.streak.length - 1; i >= 0; i--) {
                if (team.streak[i] === type) count++;
                else break;
            }
            currentStreak = `${type}${count}`;
        } else {
            currentStreak = '-';
        }

        return {
            ...team,
            streak: currentStreak,
            // Format points to 2 decimal places for display consistency
            pointsFor: parseFloat(team.pointsFor.toFixed(2)),
            pointsAgainst: parseFloat(team.pointsAgainst.toFixed(2))
        };
    });

    // Sort: Wins desc, then PF desc
    return standings.sort((a, b) => {
        if (b.wins !== a.wins) return b.wins - a.wins;
        return b.pointsFor - a.pointsFor;
    });
}

/**
 * Fetch Super Bowl (Week 17) Matchup from Realtime Database
 */
async function fetchSuperBowlMatchup(season) {
    console.log(`Fetching Super Bowl matchup for season ${season}...`);
    try {
        const fantasyData = await fetchFantasyData(season);
        if (!fantasyData || !fantasyData.weeks) return null;

        // Week 17 is usually the Championship week
        const week17 = fantasyData.weeks['17'];
        if (!week17 || !week17.matchups) {
            console.log('Week 17 data not found');
            return null;
        }

        // Find the "Final" matchup. 
        // In a 4-team playoff, there might be a 3rd place game too.
        // We assume the Championship is the one with the highest combined score 
        // OR we'd need a specific ID. For now, let's pick the one determined by logic
        // or just pick the first one if we assume brackets are ordered.
        // Better logic: Pick the matchup with the higher seeds? 
        // Or specific team names if we knew them.
        // For Topina, let's assume the first matchup in the list is the Championship
        // or refine if we see multiple.

        // Let's log them to see
        console.log('Week 17 Matchups:', week17.matchups);

        // For now, return the first matchup
        if (week17.matchups.length > 0) {
            return week17.matchups[0];
        }
        return null;

    } catch (error) {
        console.error("Error fetching Super Bowl matchup:", error);
        return null;
    }
}


/**
 * Render standings table with data
 */
function renderStandings(standings) {
    const tbody = document.querySelector('.standings-table tbody');
    if (!tbody || !standings || standings.length === 0) return;

    // Clear existing rows
    tbody.innerHTML = '';

    standings.forEach((team, index) => {
        const rank = index + 1;
        const rankClass = rank === 1 ? 'gold' : rank === 2 ? 'silver' : rank === 3 ? 'bronze' : '';
        const streakClass = team.streak.startsWith('W') ? 'win' : 'loss';

        const row = document.createElement('tr');
        row.className = 'table-row';
        row.dataset.rank = rank;

        row.innerHTML = `
            <td><span class="rank ${rankClass}">${rank}</span></td>
            <td class="team-name">
                <span class="team-logo">üèà</span>
                <span>${team.teamName}</span>
            </td>
            <td>${team.wins}</td>
            <td>${team.losses}</td>
            <td>${formatNumber(team.pointsFor)}</td>
            <td>${formatNumber(team.pointsAgainst)}</td>
            <td><span class="streak ${streakClass}">${team.streak}</span></td>
        `;

        tbody.appendChild(row);
    });

    // Re-initialize table animations
    initTableAnimations();
}

/**
 * Render draft cards with data
 */
function renderDraft(draftPicks, round = 'all') {
    const grid = document.querySelector('.draft-grid');
    if (!grid || !draftPicks || draftPicks.length === 0) return;

    // Clear existing cards
    grid.innerHTML = '';

    const filteredPicks = round === 'all'
        ? draftPicks
        : draftPicks.filter(pick => pick.round === parseInt(round));

    filteredPicks.forEach((pick, index) => {
        const posClass = pick.position ? pick.position.toLowerCase() : '';
        const delay = (index % 8) * 50;

        const card = document.createElement('div');
        card.className = 'draft-card animate-on-scroll';
        card.dataset.delay = delay;
        card.dataset.round = pick.round;

        card.innerHTML = `
            <div class="card-glow"></div>
            <div class="pick-number">#${pick.pick}</div>
            <div class="player-position ${posClass}">${pick.position}</div>
            <div class="player-info">
                <h3 class="player-name">${pick.playerName}</h3>
                <p class="player-team">${pick.nflTeam}</p>
                <p class="team-drafted">‚Üí ${pick.fantasyTeam}</p>
            </div>
        `;

        grid.appendChild(card);
    });

    // Re-initialize scroll animations
    initScrollAnimations();
}

/**
 * Update page subtitle with current week info
 */
function updateWeekInfo(data) {
    const subtitle = document.querySelector('.page-subtitle');
    // If data comes from Firestore, we might not have 'lastUpdated' unless we store it.
    // For now, we can use the 'scraped_at' field if available in the doc
    if (subtitle && data && data.scraped_at) {
        const updateDate = new Date(data.scraped_at);
        const formattedDate = updateDate.toLocaleDateString('it-IT', {
            day: 'numeric',
            month: 'short',
            year: 'numeric'
        });
        subtitle.textContent = `Aggiornato: ${formattedDate}`;
    }
}

/**
 * Fetch all-time stats from Realtime Database
 */
/**
 * Fetch all-time stats from Realtime Database
 */
async function fetchAllTimeStats() {
    console.log("[fetchAllTimeStats] Starting fetch...");
    try {
        const dbRef = ref(db);
        const snapshot = await get(child(dbRef, "stats/all_time"));

        if (snapshot.exists()) {
            console.log("[fetchAllTimeStats] Data found:", snapshot.val());
            return snapshot.val();
        } else {
            console.log("No all-time stats found");
            return null;
        }
    } catch (error) {
        console.error("Error getting stats data:", error);
        return null;
    }
}

/**
 * Render Home Page Quick Stats
 */
function renderHomeStats(stats) {
    console.log("[renderHomeStats] Rendering...");
    const container = document.getElementById('home-stats');
    // ... rest of function (omitted for brevity in replacement, but I must match exact target content or just replace head)
    if (!container || !stats) return;

    // Helper to animate numbers
    const animateValue = (obj, start, end, duration) => {
        let startTimestamp = null;
        const step = (timestamp) => {
            if (!startTimestamp) startTimestamp = timestamp;
            const progress = Math.min((timestamp - startTimestamp) / duration, 1);
            obj.innerHTML = Math.floor(progress * (end - start) + start);
            if (progress < 1) {
                window.requestAnimationFrame(step);
            }
        };
        window.requestAnimationFrame(step);
    };

    // Update values
    const statItems = container.querySelectorAll('.home-stat');
    if (statItems.length >= 3) {
        // Teams - Assuming 12 or fetching? Stats doesn't have team count but we can approximate or use static
        // stats.seasons_count is available
        // stats.total_games is available

        // Update Seasons
        const seasonEl = statItems[1].querySelector('.stat-number');
        if (seasonEl) {
            animateValue(seasonEl, 0, stats.seasons_count || 5, 2000);
        }

        // Update Games
        const gamesEl = statItems[2].querySelector('.stat-number');
        if (gamesEl) {
            animateValue(gamesEl, 0, stats.total_games || 0, 2000);
        }
    }
}

/**
 * Render Stats Page
 */
function renderStatsPage(stats) {
    const statsGrid = document.querySelector('.stats-grid');
    const recordsGrid = document.querySelector('.records-grid');

    if (!statsGrid || !recordsGrid) return;

    // Helper for Stat Cards
    const createStatCard = (icon, value, name, delay) => `
        <div class="stat-card animate-on-scroll" data-delay="${delay}">
            <div class="stat-icon">${icon}</div>
            <div class="stat-value">${value}</div>
            <div class="stat-name">${name}</div>
        </div>
    `;

    // 1. Top Stats Grid
    let statsHtml = '';
    // Championships (hardcoded for now or from stats?)
    statsHtml += createStatCard('üèÜ', '5', 'Championships', '0'); // Assuming static 5 or fetched? Keeping 5 as placeholder or from stats if available

    // Total Points
    if (stats.total_points) {
        statsHtml += createStatCard('üìä', formatNumber(stats.total_points), 'Total Points Scored', '100');
    }

    // Highest Weekly Score
    if (stats.highest_score) {
        statsHtml += createStatCard('üéØ', stats.highest_score.value, 'Highest Weekly Score', '200');
    }

    // Avg Points/Game
    if (stats.total_points && stats.total_games) {
        const avg = (stats.total_points / stats.total_games).toFixed(1);
        statsHtml += createStatCard('üìà', avg, 'Avg Points/Game', '300');
    }

    statsGrid.innerHTML = statsHtml;


    // Helper for Record Cards
    const createRecordCard = (icon, type, value, holder, date, delay) => `
        <div class="record-card animate-on-scroll" data-delay="${delay}">
            <div class="record-header">
                <span class="record-icon">${icon}</span>
                <span class="record-type">${type}</span>
            </div>
            <div class="record-value">${value}</div>
            <div class="record-holder">${holder}</div>
            <div class="record-date">${date}</div>
        </div>
    `;

    // 2. Records Section
    let recordsHtml = '';

    // Highest Score
    if (stats.highest_score) {
        recordsHtml += createRecordCard('‚¨ÜÔ∏è', 'Highest Score', stats.highest_score.value, stats.highest_score.team, `Week ${stats.highest_score.week}, ${stats.highest_score.season}`, '0');
    }

    // Lowest Score
    if (stats.lowest_score) {
        recordsHtml += createRecordCard('‚¨áÔ∏è', 'Lowest Score', stats.lowest_score.value, stats.lowest_score.team, `Week ${stats.lowest_score.week}, ${stats.lowest_score.season}`, '100');
    }

    // Win Streak (Assuming stats has this, otherwise skip or placeholder)
    if (stats.longest_win_streak) {
        recordsHtml += createRecordCard('üî•', 'Win Streak', stats.longest_win_streak.value, stats.longest_win_streak.team, `${stats.longest_win_streak.season} Season`, '200');
    }

    // Loss Streak
    if (stats.longest_loss_streak) {
        recordsHtml += createRecordCard('üíÄ', 'Loss Streak', stats.longest_loss_streak.value, stats.longest_loss_streak.team, `${stats.longest_loss_streak.season} Season`, '300');
    }

    // Season Points
    if (stats.most_points_season) {
        recordsHtml += createRecordCard('üìÖ', 'Season Points', formatNumber(stats.most_points_season.value), stats.most_points_season.team, `${stats.most_points_season.season} Season`, '400');
    }

    // Largest Margin
    if (stats.largest_margin) {
        recordsHtml += createRecordCard('‚öîÔ∏è', 'Largest Margin', stats.largest_margin.value, `${stats.largest_margin.winner} def. ${stats.largest_margin.loser}`, `Week ${stats.largest_margin.week}, ${stats.largest_margin.season}`, '500');
    }

    recordsGrid.innerHTML = recordsHtml;

    // Re-init animations
    initCounterAnimations();
    initScrollAnimations();
}

/**
 * Initialize data loading on page load
 */
/**
 * Initialize data loading on page load
 */
async function initDataLoading() {
    console.log("üöÄ Initializing Data Loading from Firebase...");

    // Update standings page
    console.log("Checking standings table...");
    if (document.querySelector('.standings-table')) {
        console.log("Found standings table");
        const fantasyData = await fetchFantasyData(CURRENT_SEASON);
        if (fantasyData) {
            const standings = processFantasyData(fantasyData);
            renderStandings(standings);
            updateWeekInfo(fantasyData);
        }
    }

    // Update draft page
    console.log("Checking draft grid...");
    if (document.querySelector('.draft-grid')) {
        console.log("Found draft grid");
        const draftDoc = await fetchDraftData(CURRENT_SEASON);
        if (draftDoc) {
            const flatPicks = flattenDraftData(draftDoc);
            renderDraft(flatPicks);

            // Hook up round selector with real data
            const roundBtns = document.querySelectorAll('.round-btn');
            roundBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    roundBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    renderDraft(flatPicks, btn.dataset.round);
                });
            });
        }
    }

    // Update Home Page Stats and Stats Page
    const homeStats = document.getElementById('home-stats');
    const statsGrid = document.querySelector('.stats-grid');
    console.log("Checking stats containers:", { homeStats: !!homeStats, statsGrid: !!statsGrid });

    if (homeStats || statsGrid) {
        console.log("Found stats container, fetching data...");
        const allTimeStats = await fetchAllTimeStats();
        console.log("Fetched stats:", allTimeStats ? "Yes" : "No");
        if (allTimeStats) {
            if (homeStats) renderHomeStats(allTimeStats);
            if (statsGrid) renderStatsPage(allTimeStats);
        }
    }
}

// Initialize data loading after DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    // Small delay to ensure other init functions run first
    setTimeout(initDataLoading, 100);
});
